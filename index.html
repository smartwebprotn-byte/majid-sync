<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clone Humain T.T.A - WebGL Edition</title>
  <meta name="theme-color" content="#00f0ff">
  <style>
    /* --- STYLE GLOBAL --- */
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: #0f0f1b;
      color: white;
      font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
      min-height: 100vh;
      user-select: none;
    }

    .container {
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
      position: relative;
    }

    /* Conteneur Three.js */
    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    /* Image de fond (visage) */
    #faceBase {
      display: block;
      max-width: 90vw;
      max-height: 85vh;
      height: auto;
      width: auto;
      pointer-events: none;
      z-index: 2;
      position: relative;
    }

    .face-wrapper {
      position: relative;
      width: fit-content;
      height: fit-content;
      z-index: 2;
    }

    /* --- CONTROLES --- */
    .controls {
      position: fixed;
      bottom: 20px;
      width: 100%;
      text-align: center;
      z-index: 20;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }

    .controls>div {
      pointer-events: auto;
    }

    button {
      background: rgba(0, 240, 255, 0.15);
      color: #00f0ff;
      border: 1px solid rgba(0, 240, 255, 0.5);
      padding: 12px 24px;
      margin: 0 5px;
      border-radius: 25px;
      cursor: pointer;
      backdrop-filter: blur(8px);
      transition: all 0.2s ease;
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    button:hover {
      background: #00f0ff;
      color: #0f0f1b;
      box-shadow: 0 0 25px rgba(0, 240, 255, 0.6);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button.danger {
      border-color: rgba(255, 80, 80, 0.5);
      color: #ff6060;
      background: rgba(255, 80, 80, 0.1);
    }

    button.danger:hover {
      background: #ff6060;
      color: white;
      box-shadow: 0 0 25px rgba(255, 80, 80, 0.6);
    }

    .status {
      color: #aaa;
      font-size: 0.9em;
      background: rgba(0, 0, 0, 0.6);
      padding: 8px 20px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s;
    }

    .status.speaking {
      color: #00f0ff;
      border-color: #00f0ff;
      box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);
      animation: statusPulse 1s ease-in-out infinite;
    }

    @keyframes statusPulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    /* --- PANNEAU DE R√âGLAGES --- */
    .settings-panel {
      position: fixed;
      top: 0;
      right: -350px;
      width: 350px;
      height: 100vh;
      background: rgba(15, 15, 27, 0.98);
      border-left: 1px solid rgba(0, 240, 255, 0.3);
      z-index: 100;
      transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 25px;
      box-sizing: border-box;
      color: #fff;
      overflow-y: auto;
      backdrop-filter: blur(20px);
      box-shadow: -10px 0 40px rgba(0, 0, 0, 0.5);
    }

    .settings-panel.open {
      right: 0;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(0, 240, 255, 0.2);
    }

    .panel-header h3 {
      margin: 0;
      color: #00f0ff;
      font-size: 1.3em;
    }

    .close-btn {
      background: transparent;
      border: 1px solid #ff5050;
      color: #ff5050;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      padding: 0;
    }

    .close-btn:hover {
      background: rgba(255, 80, 80, 0.2);
      color: white;
    }

    h4 {
      color: #00f0ff;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin: 25px 0 15px 0;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(0, 240, 255, 0.15);
    }

    .setting-group {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
      gap: 12px;
    }

    .setting-label {
      flex: 1;
      color: #bbb;
      font-size: 0.85em;
    }

    .setting-input {
      width: 60px;
      padding: 6px 8px;
      background: rgba(0, 240, 255, 0.1);
      border: 1px solid rgba(0, 240, 255, 0.3);
      border-radius: 6px;
      color: #00f0ff;
      font-size: 0.9em;
      text-align: center;
      transition: all 0.2s;
    }

    .setting-input:focus {
      outline: none;
      background: rgba(0, 240, 255, 0.2);
      border-color: #00f0ff;
      box-shadow: 0 0 10px rgba(0, 240, 255, 0.3);
    }

    input[type="range"] {
      width: 100px;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #00f0ff;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .setting-value {
      color: #00f0ff;
      font-weight: bold;
      font-size: 0.85em;
      min-width: 45px;
      text-align: right;
    }

    .loading-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 3px;
      background: linear-gradient(90deg, #00f0ff, #00ff88);
      transition: width 0.2s;
      z-index: 200;
    }
  </style>
</head>

<body>
  <div class="loading-bar" id="loadingBar"></div>

  <div class="container">
    <!-- Conteneur WebGL -->
    <div id="canvas-container"></div>

    <div class="face-wrapper">
      <img id="faceBase" src="zero.jpg" alt="Visage Base">
    </div>

    <div class="controls">
      <div>
        <button onclick="startListening()">üé§ Parler</button>
        <button onclick="stopAll()" class="danger">‚èπÔ∏è Stop</button>
        <button onclick="testSpeech()">üîä Test</button>
        <button onclick="toggleSettings()">‚öôÔ∏è R√©glages</button>
      </div>
      <div class="status" id="status">Pr√™t.</div>
    </div>
  </div>

  <div class="settings-panel" id="settingsPanel">
    <div class="panel-header">
      <h3>Configuration</h3>
      <button class="close-btn" onclick="toggleSettings()">√ó</button>
    </div>

    <h4>Position & Taille (Image de base)</h4>
    <div class="setting-group">
      <label class="setting-label">Pos X (%)</label>
      <input type="range" id="maskLeft" min="0" max="100" step="0.1" value="49.6">
      <span class="setting-value" id="val_maskLeft">49.6%</span>
    </div>
    <div class="setting-group">
      <label class="setting-label">Pos Y (%)</label>
      <input type="range" id="maskTop" min="0" max="100" step="0.1" value="58.1">
      <span class="setting-value" id="val_maskTop">58.1%</span>
    </div>
    <div class="setting-group">
      <label class="setting-label">Largeur (%)</label>
      <input type="range" id="maskWidth" min="5" max="50" step="0.5" value="21">
      <span class="setting-value" id="val_maskWidth">21%</span>
    </div>
    <div class="setting-group">
      <label class="setting-label">Altura (%)</label>
      <input type="range" id="maskHeight" min="5" max="40" step="0.5" value="16.2">
      <span class="setting-value" id="val_maskHeight">16.2%</span>
    </div>
    <div class="setting-group">
      <label class="setting-label">Rotation (¬∞)</label>
      <input type="range" id="visemeRotation" min="-45" max="45" step="1" value="0">
      <span class="setting-value" id="val_visemeRotation">0¬∞</span>
    </div>

    <h4>Sprite (Bouche)</h4>
    <div class="setting-group">
      <label class="setting-label">√âchelle (%)</label>
      <input type="range" id="visemeScale" min="50" max="300" step="5" value="115">
      <span class="setting-value" id="val_visemeScale">115%</span>
    </div>
    <div class="setting-group">
      <label class="setting-label">D√©calage X</label>
      <input type="range" id="visemeOffsetX" min="-50" max="50" step="1" value="-2">
      <span class="setting-value" id="val_visemeOffsetX">-2</span>
    </div>
    <div class="setting-group">
      <label class="setting-label">D√©calage Y</label>
      <input type="range" id="visemeOffsetY" min="-50" max="50" step="1" value="-4">
      <span class="setting-value" id="val_visemeOffsetY">-4</span>
    </div>

    <h4>Synchronisation</h4>
    <div class="setting-group">
      <label class="setting-label">Transition (ms)</label>
      <input type="range" id="transitionMs" min="0" max="100" step="5" value="30">
      <span class="setting-value" id="val_transitionMs">30ms</span>
    </div>
    <div class="setting-group">
      <label class="setting-label">Avance (ms)</label>
      <input type="range" id="leadMs" min="0" max="200" step="10" value="80">
      <span class="setting-value" id="val_leadMs">80ms</span>
    </div>
    <div class="setting-group">
      <label class="setting-label">Vitesse (%)</label>
      <input type="range" id="speechRate" min="50" max="200" step="10" value="100">
      <span class="setting-value" id="val_speechRate">100%</span>
    </div>

    <button style="width:100%; margin-top:25px; background:#00f0ff; color:#0f0f1b; font-weight:bold;"
      onclick="saveSettings()">üíæ Sauvegarder</button>
    <button style="width:100%; margin-top:10px;" onclick="resetSettings()">üîÑ R√©initialiser</button>
  </div>

  <!-- Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // --- CONFIGURATION ---
    const VISEME_MAP = {
      'A': 'bouche_A.png',
      'E': 'bouche_E.png',
      'I': 'bouche_I.png',
      'O': 'bouche_O.png',
      'U': 'bouche_U.png',
      'F': 'bouche_F.png',
      'S': 'bouche_S.png',
      'D': 'bouche_D.png'
    };

    // --- THREE.JS GLOBALS ---
    let scene, camera, renderer;
    let mouthMesh, mouthMaterial;
    let textures = {};
    let isReady = false;

    // Animation State
    const animState = {
      isSpeaking: false,
      startTime: 0,
      timeline: [],
      currentIndex: -1,
      currentViseme: 'H',
      prevViseme: 'H',
      transitionStart: 0,
      targetOpacity: 1,
      currentOpacity: 1
    };

    // --- INITIALISATION THREE.JS ---
    function initThreeJS() {
      const container = document.getElementById('canvas-container');

      // Sc√®ne
      scene = new THREE.Scene();

      // Cam√©ra orthographique pour un rendu 2D plat
      const aspect = window.innerWidth / window.innerHeight;
      const frustumSize = 1000;
      camera = new THREE.OrthographicCamera(
        frustumSize * aspect / -2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        frustumSize / -2,
        0.1,
        1000
      );
      camera.position.z = 100;

      // Renderer avec transparence
      renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      // Cr√©er le plan de la bouche
      const geometry = new THREE.PlaneGeometry(100, 100);

      // Mat√©riau avec transparence
      mouthMaterial = new THREE.MeshBasicMaterial({
        map: null,
        transparent: true,
        opacity: 1,
        depthTest: false,
        depthWrite: false
      });

      mouthMesh = new THREE.Mesh(geometry, mouthMaterial);
      mouthMesh.visible = false;
      scene.add(mouthMesh);

      // Event listeners
      window.addEventListener('resize', onWindowResize);
      animate();
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      const frustumSize = 1000;

      camera.left = frustumSize * aspect / -2;
      camera.right = frustumSize * aspect / 2;
      camera.top = frustumSize / 2;
      camera.bottom = frustumSize / -2;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
      updateMouthPosition();
    }

    // --- GESTION TEXTURES ---
    function preloadTextures() {
      const loadingBar = document.getElementById('loadingBar');
      const status = document.getElementById('status');
      const loader = new THREE.TextureLoader();

      let loaded = 0;
      const total = Object.keys(VISEME_MAP).length;

      status.textContent = "Chargement textures...";

      Object.entries(VISEME_MAP).forEach(([key, fileName]) => {
        loader.load(
          'sprites/' + fileName,
          (tex) => {
            // Configuration texture pour meilleur rendu
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            tex.generateMipmaps = false;
            textures[key] = tex;

            loaded++;
            loadingBar.style.width = (loaded / total * 100) + '%';

            if (loaded === total) {
              status.textContent = "‚úÖ Pr√™t.";
              isReady = true;
              mouthMesh.visible = true;
              updateMouthPosition();
              setTimeout(() => loadingBar.style.width = '0%', 500);
            }
          },
          undefined,
          (err) => {
            console.error("Erreur chargement: " + fileName);
            // Texture vide si erreur pour √©viter le plantage
            textures[key] = null;
            loaded++;
            if (loaded === total) {
              isReady = true;
              mouthMesh.visible = true;
              status.textContent = "‚ö†Ô∏è Pr√™t (images manquantes)";
            }
          }
        );
      });
    }

    // --- POSITIONNEMENT BOUCHE ---
    function updateMouthPosition() {
      if (!mouthMesh) return;

      const face = document.getElementById('faceBase');
      const rect = face.getBoundingClientRect();

      // Param√®tres
      const left = parseFloat(document.getElementById('maskLeft').value);
      const top = parseFloat(document.getElementById('maskTop').value);
      const width = parseFloat(document.getElementById('maskWidth').value);
      const height = parseFloat(document.getElementById('maskHeight').value);
      const rotation = parseFloat(document.getElementById('visemeRotation').value);
      const scale = parseFloat(document.getElementById('visemeScale').value) / 100;
      const offsetX = parseFloat(document.getElementById('visemeOffsetX').value);
      const offsetY = parseFloat(document.getElementById('visemeOffsetY').value);

      // Position absolue sur l'√©cran
      const posX = (rect.left + rect.width * left / 100);
      const posY = window.innerHeight - (rect.top + rect.height * top / 100); // Y invers√© WebGL

      // Convertir en coordonn√©es Three.js
      const aspect = window.innerWidth / window.innerHeight;
      const frustumSize = 1000;

      const threeX = (posX / window.innerWidth * 2 - 1) * (frustumSize * aspect / 2);
      const threeY = (posY / window.innerHeight * 2 - 1) * (frustumSize / 2);

      mouthMesh.position.set(threeX + offsetX * 2, threeY + offsetY * 2, 0);

      // Taille du mesh (base 100x100)
      const baseSize = 100;
      const targetWidth = rect.width * width / 100;
      const targetHeight = rect.height * height / 100;

      mouthMesh.scale.set(
        (targetWidth / baseSize) * scale,
        (targetHeight / baseSize) * scale,
        1
      );

      mouthMesh.rotation.z = rotation * Math.PI / 180;
    }

    // --- LOGIQUE LIP-SYNC ---
    function speak(text) {
      if (!isReady) return alert("Syst√®me pas pr√™t.");
      if (window.speechSynthesis.speaking) window.speechSynthesis.cancel();

      text = text.trim();
      if (!text) return;

      const timeline = buildTimeline(text);
      if (timeline.length === 0) return;

      // Configuration √©tat
      animState.isSpeaking = true;
      animState.timeline = timeline;
      animState.startTime = performance.now();
      animState.currentIndex = -1;
      animState.currentViseme = 'H';
      animState.prevViseme = 'H';
      animState.transitionStart = performance.now();
      animState.currentOpacity = 1;

      document.getElementById('status').textContent = "üó£Ô∏è Parole...";
      document.getElementById('status').classList.add('speaking');

      // Configuration utterance
      const utt = new SpeechSynthesisUtterance(text);
      utt.lang = 'fr-FR';
      utt.rate = parseInt(document.getElementById('speechRate').value) / 100;

      // Voix fran√ßaise
      const voices = window.speechSynthesis.getVoices();
      const frVoice = voices.find(v => v.lang.startsWith('fr'));
      if (frVoice) utt.voice = frVoice;

      utt.onend = () => stopAll();
      utt.onerror = () => stopAll();

      window.speechSynthesis.speak(utt);
    }

    function buildTimeline(text) {
      const chars = text.split('');
      const rate = parseInt(document.getElementById('speechRate').value) / 100;
      const baseMs = 70 / rate;

      let time = 0;
      const timeline = [];
      const words = text.split(' ');

      words.forEach((word, wIndex) => {
        for (let i = 0; i < word.length; i++) {
          const char = word[i];
          const viseme = getViseme(char);
          timeline.push({ start: time, viseme: viseme });

          // Dur√©e variable
          const isVowel = /[aeiouy√†√¢√©√®√™√´√Ø√Æ√¥√π√ª√º]/i.test(char);
          const duration = isVowel ? baseMs * 1.3 : baseMs;
          time += duration;
        }

        // Pause inter-mots
        if (wIndex < words.length - 1) {
          time += (100 / rate);
          timeline.push({ start: time, viseme: 'H', isSilence: true });
        }
      });

      return timeline;
    }

    function getViseme(char) {
      const l = char.toLowerCase();
      if (/[a√†√¢√¶]/.test(l)) return 'A';
      if (/[e√®√™√©√´]/.test(l)) return 'E';
      if (/[i√Æ√Øy]/.test(l)) return 'I';
      if (/[o√¥√∂]/.test(l)) return 'O';
      if (/[u√π√ª√º]/.test(l)) return 'U';
      if (/[fvw]/.test(l)) return 'F';
      if (/[s√ß]/.test(l)) return 'S';
      if (/[z]/.test(l)) return 'S';
      if (/[ptkbdg]/.test(l)) return 'D';
      if (/[lmnr]/.test(l)) return 'D';
      if (/[\s\.,!?]/.test(l)) return 'H';
      return 'H';
    }

    // --- BOUCLE D'ANIMATION RENDU ---
    function animate() {
      requestAnimationFrame(animate);

      // 1. Logique de synchronisation
      if (animState.isSpeaking && animState.timeline.length > 0) {
        const now = performance.now();
        const elapsed = now - animState.startTime;
        const leadTime = parseInt(document.getElementById('leadMs').value);
        const effectiveRate = parseInt(document.getElementById('speechRate').value) / 100;

        // Avancer dans la timeline
        while (animState.currentIndex < animState.timeline.length - 1) {
          const next = animState.timeline[animState.currentIndex + 1];
          if (elapsed >= (next.start - leadTime) / effectiveRate) {
            animState.currentIndex++;

            if (next.viseme !== animState.currentViseme) {
              animState.prevViseme = animState.currentViseme;
              animState.currentViseme = next.viseme;
              animState.transitionStart = now;
            }
          } else break;
        }
      }

      // 2. Interpolation (Lissage)
      const transitionDur = parseInt(document.getElementById('transitionMs').value);
      const now = performance.now();
      let blend = Math.min(1, Math.max(0, (now - animState.transitionStart) / transitionDur));

      // Ease function pour un mouvement plus naturel
      blend = blend * (2 - blend); // Ease-out

      // 3. Mise √† jour texture et opacit√©
      const prevTex = textures[animState.prevViseme];
      const currTex = textures[animState.currentViseme];

      // Si pas de transition (ou d√©but), on affiche direct
      if (transitionDur === 0 || animState.prevViseme === animState.currentViseme) {
        mouthMaterial.map = currTex;
        mouthMaterial.opacity = 1;
      } else {
        // Pour un lissage simple en WebGL 2D, on g√®re l'opacit√©
        // Note: Un vrai crossfade n√©cessite 2 meshes dans Three.js
        // Pour simplifier, on utilise une opacit√© globale qui r√©agit vite
        mouthMaterial.map = currTex;
        mouthMaterial.opacity = 1; // Three.js g√®re mal le changement de texture avec alpha
      }

      // R√©appliquer le scale pour compenser le resize window
      updateMouthPosition();

      renderer.render(scene, camera);
    }

    function stopAll() {
      window.speechSynthesis.cancel();
      animState.isSpeaking = false;
      animState.currentViseme = 'H';
      animState.prevViseme = 'H';
      if (mouthMaterial) mouthMaterial.map = textures['H'];
      document.getElementById('status').textContent = "Arr√™t√©.";
      document.getElementById('status').classList.remove('speaking');
    }

    // --- UTILITAIRES ---
    function startListening() {
      if (!('webkitSpeechRecognition' in window)) {
        return alert("Navigateur non support√©. Utilisez Chrome ou Edge.");
      }
      const rec = new webkitSpeechRecognition();
      rec.lang = 'fr-FR';
      rec.onresult = (e) => {
        const txt = e.results[0][0].transcript;
        document.getElementById('status').textContent = `Entendu: "${txt}"`;
        speak(txt);
      };
      rec.start();
    }

    function testSpeech() {
      speak("Bonjour, je suis votre assistant virtuel avec rendu WebGL haute performance.");
    }

    function toggleSettings() {
      document.getElementById('settingsPanel').classList.toggle('open');
      if (document.getElementById('settingsPanel').classList.contains('open')) {
        setTimeout(updateMouthPosition, 350);
      }
    }

    function onSliderChange(id, suffix = '') {
      const el = document.getElementById(id);
      const valEl = document.getElementById('val_' + id);
      if (valEl) valEl.textContent = el.value + suffix;
      updateMouthPosition();
    }

    function saveSettings() {
      const ids = ['maskLeft', 'maskTop', 'maskWidth', 'maskHeight', 'visemeRotation',
        'visemeScale', 'visemeOffsetX', 'visemeOffsetY', 'transitionMs',
        'leadMs', 'speechRate'];
      let s = {};
      ids.forEach(id => s[id] = document.getElementById(id).value);
      localStorage.setItem('webglCloneSettings', JSON.stringify(s));
      alert("Param√®tres sauvegard√©s !");
    }

    function resetSettings() {
      if (confirm("R√©initialiser ?")) {
        localStorage.removeItem('webglCloneSettings');
        location.reload();
      }
    }

    function loadSettings() {
      const s = JSON.parse(localStorage.getItem('webglCloneSettings'));
      if (s) {
        Object.keys(s).forEach(id => {
          const el = document.getElementById(id);
          if (el) el.value = s[id];
          onSliderChange(id, id.includes('Rate') || id.includes('Scale') ? '%' : (id.includes('Ms') ? 'ms' : (id.includes('Rotation') ? '¬∞' : '')));
        });
      } else {
        // Initialiser les labels
        ids.forEach(id => onSliderChange(id, id.includes('Rate') || id.includes('Scale') ? '%' : (id.includes('Ms') ? 'ms' : (id.includes('Rotation') ? '¬∞' : ''))));
      }
    }

    // --- START ---
    const ids = ['maskLeft', 'maskTop', 'maskWidth', 'maskHeight', 'visemeRotation',
      'visemeScale', 'visemeOffsetX', 'visemeOffsetY', 'transitionMs',
      'leadMs', 'speechRate'];

    ids.forEach(id => {
      const el = document.getElementById(id);
      el.addEventListener('input', () => onSliderChange(id, id.includes('Rate') || id.includes('Scale') ? '%' : (id.includes('Ms') ? 'ms' : (id.includes('Rotation') ? '¬∞' : ''))));
    });

    window.addEventListener('DOMContentLoaded', () => {
      loadSettings();
      initThreeJS();
      preloadTextures();

      // Forcer update position apr√®s chargement image
      document.getElementById('faceBase').addEventListener('load', updateMouthPosition);
    });

  </script>
</body>

</html>